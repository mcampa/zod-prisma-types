import { it, expect, describe, beforeEach, vi } from 'vitest';
import type { CreateFileOptions } from '../../classes/fileWriter';
import { writeSingleFileHeading } from '../writeSingleFileHeading';

/////////////////////////////////////////////
// TEST SETUP
/////////////////////////////////////////////

describe('writeSingleFileHeading', () => {
  let mockFileOptions: CreateFileOptions;
  let writeLineCalls: string[];
  let blankLineCalls: number;

  beforeEach(() => {
    // Track write calls
    writeLineCalls = [];
    blankLineCalls = 0;

    // Setup mock file options
    mockFileOptions = {
      writer: {
        writeLine: vi.fn((line: string) => {
          writeLineCalls.push(line);
        }),
        blankLine: vi.fn(() => {
          blankLineCalls++;
        }),
      },
      writeImport: vi.fn(),
      writeImportSet: vi.fn(),
      writeExport: vi.fn(),
      writeImports: vi.fn(),
      writeHeading: vi.fn(),
      writeJSDoc: vi.fn(),
    } as unknown as CreateFileOptions;
  });

  /////////////////////////////////////////////
  // TESTS
  /////////////////////////////////////////////

  it('should write the correct heading comment', () => {
    // Execute
    writeSingleFileHeading(mockFileOptions);

    // Verify correct lines were written
    expect(writeLineCalls).toHaveLength(3);
    expect(writeLineCalls[0]).toBe(
      '/* !!! This is code generated by zod-prisma-schema. Do not edit directly. !!! */',
    );
    expect(writeLineCalls[1]).toBe('/* eslint-disable */');
    expect(writeLineCalls[2]).toBe('// @ts-nocheck');
  });

  it('should write a single blank line at the end', () => {
    // Execute
    writeSingleFileHeading(mockFileOptions);

    // Verify blank line was written
    expect(blankLineCalls).toBe(1);
  });

  it('should call writer methods in the correct order', () => {
    // Execute
    writeSingleFileHeading(mockFileOptions);

    // Verify call order
    expect(mockFileOptions.writer.writeLine).toHaveBeenCalledTimes(3);
    expect(mockFileOptions.writer.blankLine).toHaveBeenCalledTimes(1);

    // Verify order: writeLine (3 times), then blankLine (once)
    const writeLineCalls = vi.mocked(mockFileOptions.writer.writeLine).mock
      .invocationCallOrder;
    const blankLineCalls = vi.mocked(mockFileOptions.writer.blankLine).mock
      .invocationCallOrder;

    // All writeLine calls should come before the blankLine call
    expect(writeLineCalls[0]).toBeLessThan(blankLineCalls[0]);
    expect(writeLineCalls[1]).toBeLessThan(blankLineCalls[0]);
    expect(writeLineCalls[2]).toBeLessThan(blankLineCalls[0]);
  });

  it('should generate the expected output format', () => {
    // Execute
    writeSingleFileHeading(mockFileOptions);

    // Create the expected output
    const expectedLines = [
      '/* !!! This is code generated by zod-prisma-schema. Do not edit directly. !!! */',
      '/* eslint-disable */',
      '// @ts-nocheck',
      '', // blank line (final)
    ];

    // Verify the complete structure
    const actualOutput: string[] = [];
    let writeIdx = 0;
    let blankIdx = 0;

    // Reconstruct the output by interleaving writeLine and blankLine calls
    const writeCalls = vi.mocked(mockFileOptions.writer.writeLine).mock
      .invocationCallOrder;
    const blankCalls = vi.mocked(mockFileOptions.writer.blankLine).mock
      .invocationCallOrder;

    const allCalls = [
      ...writeCalls.map((order: number) => ({
        type: 'write' as const,
        order,
        idx: writeIdx++,
      })),
      ...blankCalls.map((order: number) => ({
        type: 'blank' as const,
        order,
        idx: blankIdx++,
      })),
    ].sort((a, b) => a.order - b.order);

    writeIdx = 0;
    blankIdx = 0;
    allCalls.forEach((call) => {
      if (call.type === 'write') {
        actualOutput.push(writeLineCalls[writeIdx++]);
      } else {
        actualOutput.push('');
      }
    });

    expect(actualOutput).toEqual(expectedLines);
  });
});
